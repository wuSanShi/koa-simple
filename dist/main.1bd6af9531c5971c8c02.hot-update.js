exports.id = "main";
exports.modules = {

/***/ "./platforms/server/middleWares/routers.js":
/*!*************************************************!*\
  !*** ./platforms/server/middleWares/routers.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_Router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @core/Router */ \"./core/Router.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @utils */ \"./utils/index.js\");\n/* harmony import */ var _server_config_routeSchema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @server/config/routeSchema */ \"./platforms/server/config/routeSchema.js\");\n/* harmony import */ var _server_routes_jobs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @server/routes/jobs */ \"./platforms/server/routes/jobs.js\");\n/* harmony import */ var _server_routes_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @server/routes/component */ \"./platforms/server/routes/component.js\");\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ([_server_routes_jobs__WEBPACK_IMPORTED_MODULE_3__[\"default\"], _server_routes_component__WEBPACK_IMPORTED_MODULE_4__[\"default\"]].map(routeFun => {\n  const Route = Object(_core_Router__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n  const routeInfo = routeFun(_server_config_routeSchema__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n  if (routeInfo.prefix) Route.prefix('/'.concat(routeInfo.prefix).replace(/\\/+/, '/'));\n\n  for (let [key, value] of Object.entries(routeInfo.routers)) {\n    const [method, url] = ''.concat(key).split(/\\s+/gi);\n    Route.on({\n      method,\n      url,\n      ...value\n    }, async (ctx, next, param) => {\n      if (_utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getKeyData(ctx, 'request.query.mock', false) && param.mock) {\n        ctx.response.body = {\n          data: param.mock,\n          status: 200\n        };\n      }\n\n      if (param.cation) await param.cation(ctx, next, param);\n      ctx.response.body = {\n        message: 123123\n      };\n    });\n  }\n\n  return Route;\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbGF0Zm9ybXMvc2VydmVyL21pZGRsZVdhcmVzL3JvdXRlcnMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wbGF0Zm9ybXMvc2VydmVyL21pZGRsZVdhcmVzL3JvdXRlcnMuanM/ZDRkYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUm91dGVyIGZyb20gJ0Bjb3JlL1JvdXRlcic7XHJcbmltcG9ydCBVdGlscyBmcm9tICdAdXRpbHMnO1xyXG5pbXBvcnQgUm91dGVTY2hlbWEgZnJvbSAnQHNlcnZlci9jb25maWcvcm91dGVTY2hlbWEnO1xyXG5pbXBvcnQgSm9ic1JvdXRlIGZyb20gJ0BzZXJ2ZXIvcm91dGVzL2pvYnMnO1xyXG5pbXBvcnQgY29tcG9uZW50Um91dGUgZnJvbSAnQHNlcnZlci9yb3V0ZXMvY29tcG9uZW50JztcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBbSm9ic1JvdXRlLCBjb21wb25lbnRSb3V0ZV0ubWFwKHJvdXRlRnVuPT57XHJcblx0Y29uc3QgUm91dGUgPSBSb3V0ZXIoKTtcclxuXHRjb25zdCByb3V0ZUluZm8gPSByb3V0ZUZ1bihSb3V0ZVNjaGVtYSk7XHJcblx0aWYocm91dGVJbmZvLnByZWZpeCkgUm91dGUucHJlZml4KCcvJy5jb25jYXQocm91dGVJbmZvLnByZWZpeCkucmVwbGFjZSgvXFwvKy8sICcvJykpO1xyXG5cdGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyb3V0ZUluZm8ucm91dGVycykpIHtcclxuXHRcdGNvbnN0IFttZXRob2QsIHVybF0gPSAnJy5jb25jYXQoa2V5KS5zcGxpdCgvXFxzKy9naSk7XHJcblx0XHRSb3V0ZS5vbih7IG1ldGhvZCwgdXJsLCAuLi52YWx1ZSB9LCBhc3luYyAoY3R4LCBuZXh0LCBwYXJhbSk9PnsgXHJcblx0XHRcdGlmKFV0aWxzLmdldEtleURhdGEoY3R4LCAncmVxdWVzdC5xdWVyeS5tb2NrJywgZmFsc2UpICYmIHBhcmFtLm1vY2spe1xyXG5cdFx0XHRcdGN0eC5yZXNwb25zZS5ib2R5ID0geyBcclxuXHRcdFx0XHRcdGRhdGE6ICBwYXJhbS5tb2NrLFxyXG5cdFx0XHRcdFx0c3RhdHVzOlx0IDIwMFxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH0gXHJcblx0XHRcdGlmKHBhcmFtLmNhdGlvbikgYXdhaXQgcGFyYW0uY2F0aW9uKGN0eCwgbmV4dCwgcGFyYW0pO1xyXG5cdFx0XHRjdHgucmVzcG9uc2UuYm9keSA9IHtcclxuXHRcdFx0XHRtZXNzYWdlOiAxMjMxMjNcclxuXHRcdFx0fTtcclxuXHRcdH0pIFxyXG5cdH1cclxuXHRyZXR1cm4gUm91dGVcclxufSlcclxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./platforms/server/middleWares/routers.js\n");

/***/ }),

/***/ "./utils/index.js":
/*!************************!*\
  !*** ./utils/index.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst encodeChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst decodeChars = new Array(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1);\nconst Utils = {\n  getType(source) {\n    return Object.prototype.toString.call(source).slice(8, -1).toLowerCase();\n  },\n\n  getKeyData(source = {}, keys = '', defValue, unit = '.') {\n    let tempResult = [].concat(source || {}).map(function (sourceItem) {\n      switch (Utils.getType(keys)) {\n        case 'object':\n          let tempInfo = {};\n\n          for (let i in keys) {\n            tempInfo[i] = Utils.getKeyData(sourceItem, keys[i], defValue, unit);\n          }\n\n          return tempInfo;\n\n        case 'array':\n          return Utils.getKeyData(sourceItem, keys.join(unit), defValue, unit);\n\n        case 'string':\n          let tempSource = sourceItem;\n          let tempKeys = keys.split(unit);\n\n          try {\n            tempKeys.forEach(function (keyItem, index) {\n              if (keyItem == '[]') {\n                let packKey = tempKeys.slice(index + 1).join(unit);\n                tempSource = !packKey ? tempSource : Utils.getKeyData(tempSource, packKey, defValue, unit);\n                throw new Error('isWrong');\n              }\n\n              tempSource = tempSource[keyItem];\n\n              switch (true) {\n                case index + 1 < tempKeys.length && [\"number\", \"string\"].includes(Utils.getType(tempSource)):\n                case tempSource == undefined:\n                  tempSource = defValue;\n                  throw new Error('isWrong');\n              }\n            });\n          } catch (e) {}\n\n          return tempSource;\n      }\n    });\n    return Utils.getType(source) == 'array' ? tempResult : tempResult.shift();\n  },\n\n  setKeyData(source, keys = [], value, isMult = false, unit = '.') {\n    let temp = source;\n    if (!source) return;\n\n    switch (Utils.getType(keys)) {\n      case 'array':\n        keys = keys.join(unit).split(unit);\n        break;\n\n      case 'string':\n      case 'number':\n        keys = ''.concat(keys).split(unit);\n        break;\n    }\n\n    [].concat(keys).forEach(function (key, index) {\n      if (['', 'null', 'NaN', 'undefined'].includes(''.concat(key))) return;\n\n      if (index + 1 == keys.length) {\n        if (!isMult) return temp[key] = value;\n        temp[key] = [].concat(temp[key] || [], value);\n      }\n\n      ;\n      if (!temp[key]) temp[key] = {};\n      temp = temp[key];\n    });\n    return temp;\n  },\n\n  removeKeyData(source, keys, unit = '.') {\n    if (keys == undefined || keys == false) return;\n\n    switch (Utils.getType(keys)) {\n      case 'array':\n        keys = keys.join(unit);\n        break;\n    }\n\n    let tempKeys = keys.split(unit);\n    let popKey = tempKeys.pop();\n    let temp = Utils.getKeyData(source, tempKeys.join('.'), source);\n\n    switch (Utils.getType(temp)) {\n      case 'arry':\n        if (/^[0-9]+$/.test(popKey)) temp.splice(popKey, 1);else temp = temp.filter(item => item != popKey);\n        break;\n\n      case 'object':\n        delete temp[popKey];\n\n      default:\n        break;\n    }\n\n    return source;\n  },\n\n  getUnique(arr, keys) {\n    let temps = [],\n        tempMap = {};\n    [].concat(arr || []).forEach(function (item, index) {\n      let tempKey = undefined;\n\n      switch (Utils.getType(item)) {\n        case 'string':\n        case 'number':\n          tempKey = item;\n          break;\n\n        case 'object':\n          tempKey = Utils.getKeyData(item, keys);\n          break;\n      }\n\n      if (tempKey === undefined) return;\n\n      if (!tempMap[tempKey]) {\n        temps.push(item);\n        tempMap[tempKey] = true;\n      }\n    });\n    return temps;\n  },\n\n  getPackClass(arr, config) {\n    if (!config) return this;\n    let tempMap = {\n      classMap: {},\n      classDatas: {}\n    };\n\n    let Tool_PackData = function (data, config) {\n      var nodeParam = {\n        isValid: false\n      };\n\n      for (let i in config) {\n        if (config[i].validate(data)) {\n          nodeParam.isValid = true;\n          nodeParam.data = {\n            key: i,\n            source: data,\n            config: config[i],\n            id: config[i].id && ''.concat(config[i].id(data)).replace(/\\./g, '#'),\n            title: config[i].title && config[i].title(data)\n          };\n          const {\n            id,\n            title,\n            validate,\n            childs,\n            ...other\n          } = config[i];\n          Utils.assignValue(other, nodeParam.data, data);\n          if (config[i].childs) nodeParam.data.childs = [].concat(config[i].childs(data) || []);\n          break;\n        }\n\n        ;\n      }\n\n      return nodeParam;\n    };\n\n    let tempCycle = function (arr, obj, config, parent) {\n      const childDatas = [];\n      [].concat(arr).forEach(function (item, index) {\n        let itemNode = Tool_PackData(item, config);\n        if (!itemNode.isValid) return;\n        if (parent && parent.id) itemNode.data.tempParentId = parent.id;\n\n        if (parent) {\n          itemNode.data.parentId = parent.id;\n          itemNode.data.parentKey = parent.key;\n          itemNode.data.parent = parent;\n        }\n\n        ;\n        Utils.setKeyData(obj.classMap, [itemNode.data.key, itemNode.data.id], itemNode.data);\n        Utils.setKeyData(obj.classMap, ['all', itemNode.data.id], itemNode.data);\n        Utils.setKeyData(obj.classDatas, itemNode.data.key, item, true);\n        Utils.setKeyData(obj.classDatas, 'all', item, true);\n        if (itemNode.data.childs) itemNode.data.childs = tempCycle(itemNode.data.childs, obj, config, itemNode.data);\n        childDatas.push(itemNode.data);\n      });\n      return childDatas;\n    };\n\n    tempCycle(arr, tempMap, config);\n    return tempMap;\n  },\n\n  getUrlByQuery(obj) {\n    let query = [];\n\n    for (let key in obj) {\n      if (obj[key] === undefined || !''.concat(obj[key]).length) continue;\n      [].concat(obj[key]).forEach(function (item) {\n        query.push(''.concat(key, '=', encodeURI(item)));\n      });\n    }\n\n    return query.join('&');\n  },\n\n  getQueryByUrl(searchStr) {\n    let tempUrl = decodeURIComponent(searchStr || window.location.hash || window.location.search);\n    let reg = /[\\?&]([^=]+)[=\\s]+([^&]+);?/g;\n    let tempMap = {};\n\n    while (reg.exec(tempUrl)) tempMap[''.concat(RegExp.$1).trim()] = ''.concat(RegExp.$2).trim();\n\n    return tempMap;\n  },\n\n  getPackTree(arr, config) {\n    let temps = [],\n        datas = [].concat(arr),\n        tempMap = {},\n        tempTypeMap = {};\n\n    let Tool_PackData = function (data, config) {\n      let nodeParam = {\n        isValid: false\n      };\n\n      for (let i in config) {\n        if (config[i].validate(data)) {\n          nodeParam.isValid = true;\n          nodeParam.tag = config[i].tag;\n          nodeParam.data = {\n            key: i,\n            source: data,\n            config: config[i],\n            id: config[i].id(data)\n          };\n          const {\n            id,\n            tag,\n            validate,\n            parentId,\n            childId,\n            ...other\n          } = config[i];\n          Utils.assignValue(other, nodeParam.data, data);\n          if (config[i].parentId) Utils.setKeyData(nodeParam.data, 'parentId', config[i].parentId(data));\n          if (config[i].childId) Utils.setKeyData(nodeParam.data, 'childId', config[i].childId(data));\n          break;\n        }\n\n        ;\n      }\n\n      return nodeParam;\n    };\n\n    let toolData = function (data, map, typeMap) {\n      Utils.setKeyData(map, data.key, data.source, true);\n      Utils.setKeyData(typeMap, [data.key, data.id], data.source);\n      Utils.setKeyData(typeMap, ['all', data.id], data);\n    };\n\n    let tempCycle = function (list, data, config) {\n      list.forEach(function (item, index) {\n        let itemNode = Tool_PackData(item, config);\n        if (!itemNode.isValid) return;\n\n        switch (true) {\n          case itemNode.data.parentId == data.id:\n          case Utils.getType(data.childId) == 'array' && \"^\".concat(data.childId.join(\"^\"), \"^\").includes(\"^\" + itemNode.data.id + \"^\"):\n          case Utils.getType(data.childId) == 'string' && itemNode.data.id == data.childId:\n            Utils.setKeyData(data, 'source.packChilds', itemNode.data.source, true);\n            break;\n        }\n\n        switch (true) {\n          case itemNode.data.id == data.parentId:\n          case Utils.getType(itemNode.data.childId) == 'array' && \"^\".concat(itemNode.data.childId.join(\"^\"), \"^\").includes(\"^\" + data.id + \"^\"):\n          case Utils.getType(itemNode.data.childId) == 'string' && itemNode.data.childId == data.id:\n            data.parentKey = itemNode.data.key;\n            data.parentId = itemNode.data.id;\n            Utils.setKeyData(itemNode.data, 'source.packChilds', data.source, true);\n            break;\n        }\n      });\n      return data;\n    };\n\n    while (!!datas.length) {\n      let item = Tool_PackData(datas[0], config);\n      datas.splice(0, 1);\n      if (!item.isValid) continue;\n      toolData(item.data, tempMap, tempTypeMap);\n      let packData = tempCycle(datas, item.data, config);\n      if (item.data.parentId == undefined || item.tag == 'root') temps.push(packData.source);\n    }\n\n    ;\n    return {\n      source: temps,\n      classDatas: tempMap,\n      classMap: tempTypeMap\n    };\n  },\n\n  //1. Utils.getMapByConfig([], {key:'key.loadAllGroup.0.res.packData', isMult: true, keyFormat: function(data, key){return '{0}_{1}'.format(data.device_auto_id, data.channel_id) },dataFormat: function (data, key) { return {} } } })\n  //2.Utils.getMapByConfig([],[{key:'store', isMult: true },{ key:'store', isMult: true }])\n  getMapByConfig(arr, config, keyFormat, dataFormat, isMult) {\n    let keyList = [].concat(config || []);\n    let keysMap = {};\n\n    let parseData = function (data, map, itemKey, keyFormat, Dataformat, isMult) {\n      let tempData = data;\n      if (!map[itemKey]) map[itemKey] = {};\n      let tempMap = map[itemKey];\n      let tempKey = keyFormat ? keyFormat(data, itemKey) : Utils.getKeyData(data, itemKey, '');\n      [].concat(tempKey).map(function (itemKey) {\n        if (Dataformat) tempData = Dataformat(data);\n        Utils.setKeyData(tempMap, itemKey, tempData, isMult);\n      });\n    };\n\n    [].concat(arr || []).forEach(function (item, index) {\n      keyList.forEach(function (keyItem) {\n        switch (Utils.getType(keyItem)) {\n          case 'string':\n          case 'number':\n            return parseData(item, keysMap, keyItem, keyFormat, dataFormat, isMult);\n\n          case 'object':\n            return parseData(item, keysMap, keyItem.key, keyItem.keyFormat || keyFormat, keyItem.dataFormat || dataFormat, keyItem.isMult || isMult);\n        }\n      });\n    });\n    return keysMap;\n  },\n\n  getShuffle(arr) {\n    let i = arr.length;\n\n    while (i) {\n      let j = Math.floor(Math.random() * i--);\n      [arr[j], arr[i]] = [arr[i], arr[j]];\n    }\n\n    return arr;\n  },\n\n  getFlattenArrs(arr) {\n    return arr.reduce((plane, toBeFlatten) => plane.concat(Array.isArray(toBeFlatten) ? Utils.getFlattenArrs(toBeFlatten) : toBeFlatten), []);\n  },\n\n  assignValue(config, cacheDate = {}, sourceData) {\n    for (let key in config) {\n      switch (Utils.getType(config[key])) {\n        case 'function':\n          cacheDate[key] = config[key](sourceData);\n          break;\n\n        default:\n          cacheDate[key] = config[key];\n          break;\n      }\n    }\n\n    ;\n  },\n\n  toFixed(num, fixedNumber) {\n    switch (true) {\n      case num == undefined:\n      case num == false:\n      case num == Infinity:\n      case isNaN(value):\n        num = 0;\n        break;\n    }\n\n    return Number(num).toFixed(fixedNumber);\n  },\n\n  getStringFormat(str, obj) {\n    if (str && str.length > 0) {\n      if (Utils.getType(obj) === \"object\") {\n        for (let key in obj) {\n          let reg = new RegExp(\"({\" + ''.concat(key).replace(/[\\$]/g, '\\\\' + '$$') + \"})\", \"g\");\n          str = str.replace(reg, obj[key]);\n        }\n      } else {\n        str = str.replace(/{(\\d+)}/g, function (s, i) {\n          if (i > arguments.length) return '';\n          return arguments[i];\n        });\n      }\n    }\n\n    return str;\n  },\n\n  intValue(num) {\n    if (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) {\n      return num &= 0xFFFFFFFF;\n    }\n\n    return num;\n  },\n\n  hashCode(str) {\n    let hash = 0;\n\n    if (typeof str === 'string' && str) {\n      for (let i = 0; i < str.length; i++) {\n        hash += str.charCodeAt(i) * i;\n        hash = this.intValue(hash);\n      }\n    }\n\n    return hash;\n  },\n\n  // const fileRules = [{\n  //     reg: function(file){ return /(\\.dgs)$/.test(file.name) },\n  //     tip: formatMessage({id:'source.packages.validateFromate'}),\n  //     fallback: self.Evt_FallBack\n  // }];\n  //checkValidate({}, fileRules)\n  checkValidate(value, rules) {\n    const TypeCheckValue = function (value, reg) {\n      if (Utils.getType(reg) == 'regexp') return reg.test(value);\n\n      if (typeof reg == 'function') {\n        let flag = reg(value);\n        return flag == undefined && true || flag;\n      }\n    };\n\n    if (!rules) return true;\n    let flag = true;\n\n    try {\n      [].concat(rules || []).forEach(function (item) {\n        flag = TypeCheckValue(value, item.reg);\n\n        if (!flag) {\n          item.fallback && item.fallback(item, value);\n          throw new Error('validate is not ture');\n        }\n      });\n    } catch (e) {}\n\n    return flag;\n  },\n\n  deepCopy(obj, excludeKey, excludeType) {\n    const result = Array.isArray(obj) ? [] : {};\n\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let item = obj[key];\n        if (excludeType && new RegExp(Utils.getType(item)).test(excludeType)) continue;\n        if (excludeKey && excludeKey == key) continue;\n\n        if (typeof item === 'object' && item !== null) {\n          result[key] = Utils.deepCopy(item);\n        } else {\n          result[key] = item;\n        }\n      }\n    }\n\n    return result;\n  },\n\n  judge(type, ...arg) {\n    type = ['some', 'every'].includes(type) ? type : 'some';\n    return new Promise((resolve, reject) => {\n      try {\n        const flag = Utils.getFlattenArrs([].concat(arg))[type](item => {\n          switch (Utils.getType(item)) {\n            case 'function':\n              return item();\n\n            default:\n              return item;\n          }\n        });\n        flag ? resolve(flag) : reject(flag);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  },\n\n  filterValidate(obj) {\n    switch (Utils.getType(obj)) {\n      case 'object':\n        {\n          const newData = {};\n\n          for (let i in obj) {\n            if (obj[i] !== undefined) newData[i] = obj[i];\n          }\n\n          return newData;\n        }\n\n      case 'array':\n        {}\n        break;\n    }\n  },\n\n  encode(str) {\n    var out, i, len;\n    var c1, c2, c3;\n    str = ''.concat(str);\n    len = str.length;\n    i = 0;\n    out = \"\";\n\n    while (i < len) {\n      c1 = str.charCodeAt(i++) & 0xff;\n\n      if (i == len) {\n        out += encodeChars.charAt(c1 >> 2);\n        out += encodeChars.charAt((c1 & 0x3) << 4);\n        out += \"==\";\n        break;\n      }\n\n      c2 = str.charCodeAt(i++);\n\n      if (i == len) {\n        out += encodeChars.charAt(c1 >> 2);\n        out += encodeChars.charAt((c1 & 0x3) << 4 | (c2 & 0xF0) >> 4);\n        out += encodeChars.charAt((c2 & 0xF) << 2);\n        out += \"=\";\n        break;\n      }\n\n      c3 = str.charCodeAt(i++);\n      out += encodeChars.charAt(c1 >> 2);\n      out += encodeChars.charAt((c1 & 0x3) << 4 | (c2 & 0xF0) >> 4);\n      out += encodeChars.charAt((c2 & 0xF) << 2 | (c3 & 0xC0) >> 6);\n      out += encodeChars.charAt(c3 & 0x3F);\n    }\n\n    return out;\n  },\n\n  decode(str) {\n    var c1, c2, c3, c4;\n    var i, len, out;\n    str = ''.concat(str);\n    len = str.length;\n    i = 0;\n    out = \"\";\n\n    while (i < len) {\n      do {\n        c1 = decodeChars[str.charCodeAt(i++) & 0xff];\n      } while (i < len && c1 == -1);\n\n      if (c1 == -1) break;\n\n      do {\n        c2 = decodeChars[str.charCodeAt(i++) & 0xff];\n      } while (i < len && c2 == -1);\n\n      if (c2 == -1) break;\n      out += String.fromCharCode(c1 << 2 | (c2 & 0x30) >> 4);\n\n      do {\n        c3 = str.charCodeAt(i++) & 0xff;\n        if (c3 == 61) return out;\n        c3 = decodeChars[c3];\n      } while (i < len && c3 == -1);\n\n      if (c3 == -1) break;\n      out += String.fromCharCode((c2 & 0XF) << 4 | (c3 & 0x3C) >> 2);\n\n      do {\n        c4 = str.charCodeAt(i++) & 0xff;\n        if (c4 == 61) return out;\n        c4 = decodeChars[c4];\n      } while (i < len && c4 == -1);\n\n      if (c4 == -1) break;\n      out += String.fromCharCode((c3 & 0x03) << 6 | c4);\n    }\n\n    return out;\n  }\n\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Utils);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3V0aWxzL2luZGV4LmpzPzQyMmQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZW5jb2RlQ2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcclxuY29uc3QgZGVjb2RlQ2hhcnMgPSBuZXcgQXJyYXkoIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCA2MiwgLTEsIC0xLCAtMSwgNjMsIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDU4LCA1OSwgNjAsIDYxLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDAsIDQxLCA0MiwgNDMsIDQ0LCA0NSwgNDYsIDQ3LCA0OCwgNDksIDUwLCA1MSwgLTEsIC0xLCAtMSwgLTEsIC0xICk7XHJcbmNvbnN0IFV0aWxzID0ge1xyXG4gICAgZ2V0VHlwZShzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNvdXJjZSkuc2xpY2UoOCwtMSkudG9Mb3dlckNhc2UoKTtcclxuICAgIH0sXHJcbiAgICBnZXRLZXlEYXRhIChzb3VyY2U9e30sIGtleXM9JycsIGRlZlZhbHVlLCB1bml0PScuJyl7XHJcbiAgICAgICAgbGV0IHRlbXBSZXN1bHQgPSBbXS5jb25jYXQoc291cmNlIHx8IHt9KS5tYXAoZnVuY3Rpb24oc291cmNlSXRlbSl7XHJcbiAgICAgICAgc3dpdGNoKFV0aWxzLmdldFR5cGUoa2V5cykpe1xyXG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgICAgICAgbGV0IHRlbXBJbmZvID0ge31cclxuICAgICAgICAgICAgICAgIGZvcihsZXQgaSBpbiBrZXlzKXtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wSW5mb1tpXSA9IFV0aWxzLmdldEtleURhdGEoc291cmNlSXRlbSwga2V5c1tpXSwgZGVmVmFsdWUsIHVuaXQpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVtcEluZm9cclxuICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLmdldEtleURhdGEoc291cmNlSXRlbSwga2V5cy5qb2luKHVuaXQpLCBkZWZWYWx1ZSwgdW5pdCk7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAgICAgICBsZXQgdGVtcFNvdXJjZSA9IHNvdXJjZUl0ZW07XHJcbiAgICAgICAgICAgICAgICBsZXQgdGVtcEtleXMgPSBrZXlzLnNwbGl0KHVuaXQpO1xyXG4gICAgICAgICAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBLZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5SXRlbSwgaW5kZXgpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihrZXlJdGVtPT0nW10nKXsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFja0tleSA9ICB0ZW1wS2V5cy5zbGljZShpbmRleCsxKS5qb2luKHVuaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFNvdXJjZSA9ICFwYWNrS2V5ID8gdGVtcFNvdXJjZTogVXRpbHMuZ2V0S2V5RGF0YSh0ZW1wU291cmNlLCBwYWNrS2V5LCBkZWZWYWx1ZSwgdW5pdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzV3JvbmcnKTsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFNvdXJjZSA9IHRlbXBTb3VyY2Vba2V5SXRlbV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCh0cnVlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgKGluZGV4KzEpIDwgdGVtcEtleXMubGVuZ3RoICYmIFtcIm51bWJlclwiLFwic3RyaW5nXCJdLmluY2x1ZGVzKFV0aWxzLmdldFR5cGUodGVtcFNvdXJjZSkpOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSB0ZW1wU291cmNlPT0gdW5kZWZpbmVkOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFNvdXJjZSA9IGRlZlZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1dyb25nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfWNhdGNoKGUpe31cclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wU291cmNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiBVdGlscy5nZXRUeXBlKHNvdXJjZSk9PSdhcnJheSc/IHRlbXBSZXN1bHQgOiB0ZW1wUmVzdWx0LnNoaWZ0KClcclxuICAgIH0sXHJcbiAgICBzZXRLZXlEYXRhKHNvdXJjZSwga2V5cz1bXSwgdmFsdWUsIGlzTXVsdD1mYWxzZSwgdW5pdCA9ICcuJyl7XHJcbiAgICAgICAgbGV0IHRlbXAgPSBzb3VyY2U7XHJcbiAgICAgICAgaWYoIXNvdXJjZSkgcmV0dXJuO1xyXG4gICAgICAgIHN3aXRjaChVdGlscy5nZXRUeXBlKGtleXMpKXtcclxuICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxyXG4gICAgICAgICAgICAgICAga2V5cyA9IGtleXMuam9pbih1bml0KS5zcGxpdCh1bml0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgICAgICBrZXlzID0gJycuY29uY2F0KGtleXMpLnNwbGl0KHVuaXQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgW10uY29uY2F0KGtleXMpLmZvckVhY2goZnVuY3Rpb24oa2V5LCBpbmRleCl7XHJcbiAgICAgICAgICAgIGlmKFsnJywnbnVsbCcsJ05hTicsJ3VuZGVmaW5lZCddLmluY2x1ZGVzKCcnLmNvbmNhdChrZXkpKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZihpbmRleCsxID09IGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZighaXNNdWx0KSByZXR1cm4gdGVtcFtrZXldID0gdmFsdWVcclxuICAgICAgICAgICAgICAgIHRlbXBba2V5XSA9IFtdLmNvbmNhdCh0ZW1wW2tleV0gfHwgW10sIHZhbHVlKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZighdGVtcFtrZXldKSB0ZW1wW2tleV0gPSB7fVxyXG4gICAgICAgICAgICB0ZW1wID0gdGVtcFtrZXldXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRlbXBcclxuICAgIH0sXHJcbiAgICByZW1vdmVLZXlEYXRhKHNvdXJjZSwga2V5cywgdW5pdCA9ICcuJyl7XHJcbiAgICAgICAgaWYoa2V5cz09dW5kZWZpbmVkIHx8IGtleXMgPT0gZmFsc2UpIHJldHVybjtcclxuICAgICAgICBzd2l0Y2goVXRpbHMuZ2V0VHlwZShrZXlzKSl7XHJcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzpcclxuICAgICAgICAgICAgICAgIGtleXMgPSBrZXlzLmpvaW4odW5pdCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdGVtcEtleXMgPSBrZXlzLnNwbGl0KHVuaXQpO1xyXG4gICAgICAgIGxldCBwb3BLZXkgPSB0ZW1wS2V5cy5wb3AoKTtcclxuICAgICAgICBsZXQgdGVtcCA9IFV0aWxzLmdldEtleURhdGEoc291cmNlLCB0ZW1wS2V5cy5qb2luKCcuJyksIHNvdXJjZSk7XHJcbiAgICAgICAgc3dpdGNoIChVdGlscy5nZXRUeXBlKHRlbXApKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2FycnknOlxyXG4gICAgICAgICAgICAgICAgaWYgKC9eWzAtOV0rJC8udGVzdChwb3BLZXkpKSB0ZW1wLnNwbGljZShwb3BLZXksIDEpXHJcbiAgICAgICAgICAgICAgICBlbHNlIHRlbXAgPSB0ZW1wLmZpbHRlcihpdGVtID0+IGl0ZW0gIT0gcG9wS2V5KVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzogIFxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRlbXBbcG9wS2V5XVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNvdXJjZVxyXG4gICAgfSxcclxuICAgIGdldFVuaXF1ZShhcnIsIGtleXMpe1xyXG4gICAgICAgIGxldCB0ZW1wcyA9IFtdLCB0ZW1wTWFwID0ge307XHJcbiAgICAgICAgW10uY29uY2F0KGFyciB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpbmRleCl7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wS2V5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBzd2l0Y2goVXRpbHMuZ2V0VHlwZShpdGVtKSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wS2V5ID0gaXRlbVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBLZXkgPSBVdGlscy5nZXRLZXlEYXRhKGl0ZW0sIGtleXMpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0ZW1wS2V5PT09dW5kZWZpbmVkKSByZXR1cm4gO1xyXG4gICAgICAgICAgICBpZighdGVtcE1hcFt0ZW1wS2V5XSl7IHRlbXBzLnB1c2goaXRlbSk7IHRlbXBNYXBbdGVtcEtleV0gPSB0cnVlfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuIHRlbXBzXHJcbiAgICB9LFxyXG4gICAgZ2V0UGFja0NsYXNzKGFyciwgY29uZmlnKXtcclxuICAgICAgICBpZighY29uZmlnKSByZXR1cm4gdGhpcztcclxuICAgICAgICBsZXQgdGVtcE1hcCA9IHtjbGFzc01hcDoge30sIGNsYXNzRGF0YXM6IHt9fTtcclxuICAgICAgICBsZXQgVG9vbF9QYWNrRGF0YSA9IGZ1bmN0aW9uKGRhdGEsIGNvbmZpZyl7XHJcbiAgICAgICAgICAgIHZhciBub2RlUGFyYW0gPSB7aXNWYWxpZDogZmFsc2V9XHJcbiAgICAgICAgICAgIGZvcihsZXQgaSBpbiBjb25maWcpe1xyXG4gICAgICAgICAgICAgICAgaWYoY29uZmlnW2ldLnZhbGlkYXRlKGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZVBhcmFtLmlzVmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVQYXJhbS5kYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICAgIGksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAgICAgY29uZmlnW2ldLmlkICYmICcnLmNvbmNhdChjb25maWdbaV0uaWQoZGF0YSkpLnJlcGxhY2UoL1xcLi9nLCAnIycpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogIGNvbmZpZ1tpXS50aXRsZSAmJiBjb25maWdbaV0udGl0bGUoZGF0YSksXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7aWQsIHRpdGxlLCB2YWxpZGF0ZSwgY2hpbGRzLCAuLi5vdGhlcn0gPSBjb25maWdbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMuYXNzaWduVmFsdWUob3RoZXIsIG5vZGVQYXJhbS5kYXRhLCBkYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbmZpZ1tpXS5jaGlsZHMpIG5vZGVQYXJhbS5kYXRhLmNoaWxkcyA9IFtdLmNvbmNhdChjb25maWdbaV0uY2hpbGRzKGRhdGEpIHx8IFtdKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5vZGVQYXJhbVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHRlbXBDeWNsZSA9IGZ1bmN0aW9uKGFyciwgb2JqLCBjb25maWcsIHBhcmVudCl7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkRGF0YXMgPSBbXTtcclxuICAgICAgICAgICAgIFtdLmNvbmNhdChhcnIpLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaW5kZXgpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1Ob2RlID0gVG9vbF9QYWNrRGF0YShpdGVtLCBjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgaWYoIWl0ZW1Ob2RlLmlzVmFsaWQpIHJldHVyblxyXG4gICAgICAgICAgICAgICAgaWYocGFyZW50ICYmIHBhcmVudC5pZCkgaXRlbU5vZGUuZGF0YS50ZW1wUGFyZW50SWQgPSBwYXJlbnQuaWRcclxuICAgICAgICAgICAgICAgIGlmKHBhcmVudCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbU5vZGUuZGF0YS5wYXJlbnRJZCAgICAgID0gcGFyZW50LmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Ob2RlLmRhdGEucGFyZW50S2V5ICAgICA9IHBhcmVudC5rZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbU5vZGUuZGF0YS5wYXJlbnQgICAgICAgID0gcGFyZW50XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgVXRpbHMuc2V0S2V5RGF0YShvYmouY2xhc3NNYXAsIFtpdGVtTm9kZS5kYXRhLmtleSwgaXRlbU5vZGUuZGF0YS5pZF0sIGl0ZW1Ob2RlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgVXRpbHMuc2V0S2V5RGF0YShvYmouY2xhc3NNYXAsIFsnYWxsJywgaXRlbU5vZGUuZGF0YS5pZF0sIGl0ZW1Ob2RlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgVXRpbHMuc2V0S2V5RGF0YShvYmouY2xhc3NEYXRhcywgaXRlbU5vZGUuZGF0YS5rZXksIGl0ZW0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgVXRpbHMuc2V0S2V5RGF0YShvYmouY2xhc3NEYXRhcywgJ2FsbCcsIGl0ZW0sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaWYoaXRlbU5vZGUuZGF0YS5jaGlsZHMpIGl0ZW1Ob2RlLmRhdGEuY2hpbGRzID0gdGVtcEN5Y2xlKGl0ZW1Ob2RlLmRhdGEuY2hpbGRzLCBvYmosIGNvbmZpZywgaXRlbU5vZGUuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBjaGlsZERhdGFzLnB1c2goIGl0ZW1Ob2RlLmRhdGEpXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZERhdGFzXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0ZW1wQ3ljbGUoYXJyLCB0ZW1wTWFwLCBjb25maWcpO1xyXG4gICAgICAgIHJldHVybiB0ZW1wTWFwXHJcbiAgICB9LFxyXG4gICAgZ2V0VXJsQnlRdWVyeShvYmope1xyXG4gICAgICAgIGxldCBxdWVyeSA9IFtdO1xyXG4gICAgICAgIGZvcihsZXQga2V5IGluIG9iail7XHJcbiAgICAgICAgICAgIGlmKG9ialtrZXldID09PSB1bmRlZmluZWQgfHwgIScnLmNvbmNhdChvYmpba2V5XSkubGVuZ3RoKSBjb250aW51ZVxyXG4gICAgICAgICAgICBbXS5jb25jYXQob2JqW2tleV0pLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgICAgICBxdWVyeS5wdXNoKCcnLmNvbmNhdChrZXksJz0nLGVuY29kZVVSSShpdGVtKSkpIFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcXVlcnkuam9pbignJicpXHJcbiAgICB9LFxyXG4gICAgZ2V0UXVlcnlCeVVybChzZWFyY2hTdHIpe1xyXG4gICAgICAgIGxldCB0ZW1wVXJsID0gZGVjb2RlVVJJQ29tcG9uZW50KHNlYXJjaFN0ciB8fCB3aW5kb3cubG9jYXRpb24uaGFzaCB8fCB3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcclxuICAgICAgICBsZXQgcmVnID0gIC9bXFw/Jl0oW149XSspWz1cXHNdKyhbXiZdKyk7Py9nO1xyXG4gICAgICAgIGxldCB0ZW1wTWFwID0ge307XHJcbiAgICAgICAgd2hpbGUgKHJlZy5leGVjKHRlbXBVcmwpKSB0ZW1wTWFwWycnLmNvbmNhdChSZWdFeHAuJDEpLnRyaW0oKV0gPSAnJy5jb25jYXQoUmVnRXhwLiQyKS50cmltKCk7IFxyXG4gICAgICAgIHJldHVybiB0ZW1wTWFwO1xyXG4gICAgfSxcclxuICAgIGdldFBhY2tUcmVlKGFyciwgY29uZmlnKXtcclxuICAgICAgICBsZXQgdGVtcHMgPSBbXSwgZGF0YXMgPSBbXS5jb25jYXQoYXJyKSwgdGVtcE1hcCA9IHt9LCB0ZW1wVHlwZU1hcCA9IHt9O1xyXG4gICAgICAgIGxldCBUb29sX1BhY2tEYXRhID0gZnVuY3Rpb24oZGF0YSwgY29uZmlnKXtcclxuICAgICAgICAgICAgbGV0IG5vZGVQYXJhbSA9IHtpc1ZhbGlkOmZhbHNlfVxyXG4gICAgICAgICAgICBmb3IobGV0IGkgaW4gY29uZmlnKXtcclxuICAgICAgICAgICAgICAgIGlmKGNvbmZpZ1tpXS52YWxpZGF0ZShkYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVQYXJhbS5pc1ZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlUGFyYW0udGFnID0gY29uZmlnW2ldLnRhZztcclxuICAgICAgICAgICAgICAgICAgICBub2RlUGFyYW0uZGF0YSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAgICBpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnW2ldLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogICAgIGNvbmZpZ1tpXS5pZChkYXRhKSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHtpZCwgdGFnLCB2YWxpZGF0ZSwgcGFyZW50SWQsIGNoaWxkSWQsIC4uLm90aGVyfSA9IGNvbmZpZ1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBVdGlscy5hc3NpZ25WYWx1ZShvdGhlciwgbm9kZVBhcmFtLmRhdGEsIGRhdGEpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY29uZmlnW2ldLnBhcmVudElkKSBVdGlscy5zZXRLZXlEYXRhKG5vZGVQYXJhbS5kYXRhLCAncGFyZW50SWQnLCBjb25maWdbaV0ucGFyZW50SWQoZGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbmZpZ1tpXS5jaGlsZElkKSAgVXRpbHMuc2V0S2V5RGF0YShub2RlUGFyYW0uZGF0YSwgJ2NoaWxkSWQnLCAgY29uZmlnW2ldLmNoaWxkSWQoZGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbm9kZVBhcmFtXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgdG9vbERhdGEgPSAgZnVuY3Rpb24oZGF0YSwgbWFwLCB0eXBlTWFwKXtcclxuICAgICAgICAgICAgVXRpbHMuc2V0S2V5RGF0YShtYXAsIGRhdGEua2V5LCBkYXRhLnNvdXJjZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIFV0aWxzLnNldEtleURhdGEodHlwZU1hcCwgW2RhdGEua2V5LGRhdGEuaWRdLCBkYXRhLnNvdXJjZSk7XHJcbiAgICAgICAgICAgIFV0aWxzLnNldEtleURhdGEodHlwZU1hcCwgWydhbGwnLCBkYXRhLmlkXSwgZGF0YSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgdGVtcEN5Y2xlID0gZnVuY3Rpb24obGlzdCwgZGF0YSwgY29uZmlnKXtcclxuICAgICAgICAgICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0sIGluZGV4KXtcclxuICAgICAgICAgICAgICAgIGxldCBpdGVtTm9kZSA9IFRvb2xfUGFja0RhdGEoaXRlbSwgY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIGlmKCFpdGVtTm9kZS5pc1ZhbGlkKSByZXR1cm4gO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoKHRydWUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaXRlbU5vZGUuZGF0YS5wYXJlbnRJZCA9PSBkYXRhLmlkOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVXRpbHMuZ2V0VHlwZShkYXRhLmNoaWxkSWQpPT0nYXJyYXknICYmIFwiXlwiLmNvbmNhdChkYXRhLmNoaWxkSWQuam9pbihcIl5cIiksIFwiXlwiKS5pbmNsdWRlcyhcIl5cIisgaXRlbU5vZGUuZGF0YS5pZCArXCJeXCIpOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVXRpbHMuZ2V0VHlwZShkYXRhLmNoaWxkSWQpPT0nc3RyaW5nJyAmJiBpdGVtTm9kZS5kYXRhLmlkID09IGRhdGEuY2hpbGRJZCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLnNldEtleURhdGEoZGF0YSwgJ3NvdXJjZS5wYWNrQ2hpbGRzJywgaXRlbU5vZGUuZGF0YS5zb3VyY2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoKHRydWUpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaXRlbU5vZGUuZGF0YS5pZCA9PSBkYXRhLnBhcmVudElkOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVXRpbHMuZ2V0VHlwZShpdGVtTm9kZS5kYXRhLmNoaWxkSWQpPT0nYXJyYXknICYmIFwiXlwiLmNvbmNhdChpdGVtTm9kZS5kYXRhLmNoaWxkSWQuam9pbihcIl5cIiksIFwiXlwiKS5pbmNsdWRlcyhcIl5cIisgZGF0YS5pZCArXCJeXCIpOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVXRpbHMuZ2V0VHlwZShpdGVtTm9kZS5kYXRhLmNoaWxkSWQpPT0nc3RyaW5nJyAmJiBpdGVtTm9kZS5kYXRhLmNoaWxkSWQgPT0gZGF0YS5pZDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wYXJlbnRLZXkgPSBpdGVtTm9kZS5kYXRhLmtleTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5wYXJlbnRJZCA9IGl0ZW1Ob2RlLmRhdGEuaWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFV0aWxzLnNldEtleURhdGEoaXRlbU5vZGUuZGF0YSwgJ3NvdXJjZS5wYWNrQ2hpbGRzJywgZGF0YS5zb3VyY2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICByZXR1cm4gZGF0YVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgd2hpbGUoISFkYXRhcy5sZW5ndGgpe1xyXG4gICAgICAgICAgICBsZXQgaXRlbSA9IFRvb2xfUGFja0RhdGEoZGF0YXNbMF0sIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIGRhdGFzLnNwbGljZSgwLDEpXHJcbiAgICAgICAgICAgIGlmKCFpdGVtLmlzVmFsaWQpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB0b29sRGF0YShpdGVtLmRhdGEsIHRlbXBNYXAsIHRlbXBUeXBlTWFwKTtcclxuICAgICAgICAgICAgbGV0IHBhY2tEYXRhID0gdGVtcEN5Y2xlKGRhdGFzLCBpdGVtLmRhdGEsIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIGlmKGl0ZW0uZGF0YS5wYXJlbnRJZD09dW5kZWZpbmVkIHx8IGl0ZW0udGFnPT0ncm9vdCcpIHRlbXBzLnB1c2gocGFja0RhdGEuc291cmNlKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc291cmNlOiAgICAgdGVtcHMsXHJcbiAgICAgICAgICAgIGNsYXNzRGF0YXM6IHRlbXBNYXAsXHJcbiAgICAgICAgICAgIGNsYXNzTWFwOiAgIHRlbXBUeXBlTWFwLFxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLzEuIFV0aWxzLmdldE1hcEJ5Q29uZmlnKFtdLCB7a2V5OidrZXkubG9hZEFsbEdyb3VwLjAucmVzLnBhY2tEYXRhJywgaXNNdWx0OiB0cnVlLCBrZXlGb3JtYXQ6IGZ1bmN0aW9uKGRhdGEsIGtleSl7cmV0dXJuICd7MH1fezF9Jy5mb3JtYXQoZGF0YS5kZXZpY2VfYXV0b19pZCwgZGF0YS5jaGFubmVsX2lkKSB9LGRhdGFGb3JtYXQ6IGZ1bmN0aW9uIChkYXRhLCBrZXkpIHsgcmV0dXJuIHt9IH0gfSB9KVxyXG4gICAgLy8yLlV0aWxzLmdldE1hcEJ5Q29uZmlnKFtdLFt7a2V5OidzdG9yZScsIGlzTXVsdDogdHJ1ZSB9LHsga2V5OidzdG9yZScsIGlzTXVsdDogdHJ1ZSB9XSlcclxuICAgIGdldE1hcEJ5Q29uZmlnKGFyciwgY29uZmlnLCBrZXlGb3JtYXQsIGRhdGFGb3JtYXQsIGlzTXVsdCl7XHJcbiAgICAgICAgbGV0IGtleUxpc3QgPSBbXS5jb25jYXQoY29uZmlnIHx8IFtdKTtcclxuICAgICAgICBsZXQga2V5c01hcCA9IHt9O1xyXG4gICAgICAgIGxldCBwYXJzZURhdGEgPSAgZnVuY3Rpb24oZGF0YSwgbWFwLCBpdGVtS2V5LCBrZXlGb3JtYXQsIERhdGFmb3JtYXQsIGlzTXVsdCl7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wRGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIGlmKCFtYXBbaXRlbUtleV0pIG1hcFtpdGVtS2V5XSA9IHt9XHJcbiAgICAgICAgICAgIGxldCB0ZW1wTWFwID0gbWFwW2l0ZW1LZXldO1xyXG4gICAgICAgICAgICBsZXQgdGVtcEtleSA9IGtleUZvcm1hdCA/IGtleUZvcm1hdChkYXRhLCBpdGVtS2V5KTpVdGlscy5nZXRLZXlEYXRhKGRhdGEsIGl0ZW1LZXksJycpO1xyXG4gICAgICAgICAgICBbXS5jb25jYXQodGVtcEtleSkubWFwKGZ1bmN0aW9uKGl0ZW1LZXkpe1xyXG4gICAgICAgICAgICAgICAgaWYoRGF0YWZvcm1hdCkgdGVtcERhdGEgPSBEYXRhZm9ybWF0KGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgVXRpbHMuc2V0S2V5RGF0YSh0ZW1wTWFwLCBpdGVtS2V5LCB0ZW1wRGF0YSwgaXNNdWx0KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIFtdLmNvbmNhdChhcnIgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaW5kZXgpe1xyXG4gICAgICAgICAgICBrZXlMaXN0LmZvckVhY2goZnVuY3Rpb24oa2V5SXRlbSl7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKFV0aWxzLmdldFR5cGUoa2V5SXRlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRGF0YShpdGVtLCBrZXlzTWFwLCBrZXlJdGVtLCBrZXlGb3JtYXQsIGRhdGFGb3JtYXQsIGlzTXVsdClcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZURhdGEoaXRlbSwga2V5c01hcCwga2V5SXRlbS5rZXksIGtleUl0ZW0ua2V5Rm9ybWF0IHx8IGtleUZvcm1hdCwga2V5SXRlbS5kYXRhRm9ybWF0IHx8IGRhdGFGb3JtYXQsIGtleUl0ZW0uaXNNdWx0IHx8IGlzTXVsdClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiBrZXlzTWFwXHJcbiAgICB9LFxyXG4gICAgZ2V0U2h1ZmZsZShhcnIpe1xyXG4gICAgICAgIGxldCBpID0gYXJyLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaSkge1xyXG4gICAgICAgICAgICBsZXQgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGktLSk7XHJcbiAgICAgICAgICAgIFthcnJbal0sIGFycltpXV0gPSBbYXJyW2ldLCBhcnJbal1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfSxcclxuICAgIGdldEZsYXR0ZW5BcnJzKGFycil7XHJcbiAgICAgICAgcmV0dXJuIGFyci5yZWR1Y2UoKHBsYW5lLCB0b0JlRmxhdHRlbikgPT4gKHBsYW5lLmNvbmNhdChBcnJheS5pc0FycmF5KHRvQmVGbGF0dGVuKSA/IFV0aWxzLmdldEZsYXR0ZW5BcnJzKHRvQmVGbGF0dGVuKSA6IHRvQmVGbGF0dGVuKSksIFtdKTtcclxuICAgIH0sXHJcbiAgICBhc3NpZ25WYWx1ZShjb25maWcsIGNhY2hlRGF0ZT17fSwgc291cmNlRGF0YSl7XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluICBjb25maWcpe1xyXG4gICAgICAgICAgICBzd2l0Y2goVXRpbHMuZ2V0VHlwZSggY29uZmlnW2tleV0gKSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVEYXRlW2tleV0gPSBjb25maWdba2V5XShzb3VyY2VEYXRhKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlRGF0ZVtrZXldID0gY29uZmlnW2tleV1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICB0b0ZpeGVkKG51bSwgZml4ZWROdW1iZXIpe1xyXG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xyXG4gICAgICAgICAgICBjYXNlIG51bSA9PSB1bmRlZmluZWQ6XHJcbiAgICAgICAgICAgIGNhc2UgbnVtID09IGZhbHNlOlxyXG4gICAgICAgICAgICBjYXNlIG51bSA9PSBJbmZpbml0eTpcclxuICAgICAgICAgICAgY2FzZSBpc05hTih2YWx1ZSk6XHJcbiAgICAgICAgICAgICAgICBudW0gPSAwO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE51bWJlcihudW0pLnRvRml4ZWQoZml4ZWROdW1iZXIpO1xyXG4gICAgfSxcclxuICAgIGdldFN0cmluZ0Zvcm1hdChzdHIsIG9iail7XHJcbiAgICAgICAgaWYoc3RyICYmIHN0ci5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgIGlmKFV0aWxzLmdldFR5cGUob2JqKSA9PT0gXCJvYmplY3RcIil7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGtleSBpbiBvYmope1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZWcgPSBuZXcgUmVnRXhwKFwiKHtcIisnJy5jb25jYXQoa2V5KS5yZXBsYWNlKC9bXFwkXS9nLCdcXFxcJysnJCQnKStcIn0pXCIsXCJnXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKHJlZywgb2JqW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC97KFxcZCspfS9nLCBmdW5jdGlvbihzLGkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGkgPiBhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gJydcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cjsgIFxyXG4gICAgfSxcclxuICAgIGludFZhbHVlKG51bSkge1xyXG4gICAgICAgIGlmKG51bSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IG51bSA8IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW0gJj0gMHhGRkZGRkZGRjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bTtcclxuICAgIH0sXHJcbiAgICBoYXNoQ29kZShzdHIpe1xyXG4gICAgICAgIGxldCBoYXNoID0gMDtcclxuICAgICAgICBpZih0eXBlb2Ygc3RyPT09J3N0cmluZycgJiYgc3RyKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNoICs9IHN0ci5jaGFyQ29kZUF0KGkpKmk7XHJcbiAgICAgICAgICAgICAgICBoYXNoID0gdGhpcy5pbnRWYWx1ZShoYXNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGFzaDtcclxuICAgIH0sXHJcbiAgICAvLyBjb25zdCBmaWxlUnVsZXMgPSBbe1xyXG4gICAgLy8gICAgIHJlZzogZnVuY3Rpb24oZmlsZSl7IHJldHVybiAvKFxcLmRncykkLy50ZXN0KGZpbGUubmFtZSkgfSxcclxuICAgIC8vICAgICB0aXA6IGZvcm1hdE1lc3NhZ2Uoe2lkOidzb3VyY2UucGFja2FnZXMudmFsaWRhdGVGcm9tYXRlJ30pLFxyXG4gICAgLy8gICAgIGZhbGxiYWNrOiBzZWxmLkV2dF9GYWxsQmFja1xyXG4gICAgLy8gfV07XHJcbiAgICAvL2NoZWNrVmFsaWRhdGUoe30sIGZpbGVSdWxlcylcclxuICAgIGNoZWNrVmFsaWRhdGUodmFsdWUsIHJ1bGVzKXtcclxuICAgICAgICBjb25zdCBUeXBlQ2hlY2tWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCByZWcpe1xyXG4gICAgICAgICAgICBpZihVdGlscy5nZXRUeXBlKHJlZykgPT0gJ3JlZ2V4cCcpIHJldHVybiByZWcudGVzdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiByZWcgPT0gJ2Z1bmN0aW9uJyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmxhZyA9IHJlZyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhZyA9PSB1bmRlZmluZWQgJiYgdHJ1ZSB8fCAgZmxhZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYoIXJ1bGVzKSByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIGxldCBmbGFnID0gdHJ1ZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBbXS5jb25jYXQocnVsZXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oaXRlbSl7XHJcbiAgICAgICAgICAgICAgICBmbGFnID0gVHlwZUNoZWNrVmFsdWUodmFsdWUsIGl0ZW0ucmVnKTtcclxuICAgICAgICAgICAgICAgIGlmKCFmbGFnKXtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLmZhbGxiYWNrICYmIGl0ZW0uZmFsbGJhY2soaXRlbSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndmFsaWRhdGUgaXMgbm90IHR1cmUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9Y2F0Y2goZSl7fVxyXG4gICAgICAgIHJldHVybiBmbGFnXHJcbiAgICB9LFxyXG4gICAgZGVlcENvcHkob2JqLCBleGNsdWRlS2V5LCBleGNsdWRlVHlwZSkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEFycmF5LmlzQXJyYXkob2JqKSA/IFtdIDoge307XHJcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG9iaikge1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIGxldCBpdGVtID0gb2JqW2tleV07XHJcbiAgICAgICAgICAgIGlmKGV4Y2x1ZGVUeXBlICYmIG5ldyBSZWdFeHAoIFV0aWxzLmdldFR5cGUoaXRlbSkpLnRlc3QoZXhjbHVkZVR5cGUpICkgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmKGV4Y2x1ZGVLZXkgJiYgZXhjbHVkZUtleT09a2V5ICkgY29udGludWU7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiYgaXRlbSE9PW51bGwpIHtcclxuICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IFV0aWxzLmRlZXBDb3B5KGl0ZW0pOyBcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGl0ZW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0sXHJcbiAgICBqdWRnZSh0eXBlLC4uLmFyZyl7XHJcbiAgICAgICAgdHlwZSA9IFsnc29tZScsJ2V2ZXJ5J10uaW5jbHVkZXModHlwZSkgPyB0eXBlOiAnc29tZSc7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XHJcbiAgICAgICAgICAgIHRyeXtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZsYWc9IFV0aWxzLmdldEZsYXR0ZW5BcnJzKFtdLmNvbmNhdChhcmcpKVt0eXBlXShpdGVtPT57XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoKFV0aWxzLmdldFR5cGUoaXRlbSkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgZmxhZyA/IHJlc29sdmUoZmxhZyk6cmVqZWN0KGZsYWcpXHJcbiAgICAgICAgICAgIH1jYXRjaChlcnIpeyByZWplY3QoZXJyKSB9XHJcbiAgICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBmaWx0ZXJWYWxpZGF0ZShvYmope1xyXG4gICAgICAgIHN3aXRjaChVdGlscy5nZXRUeXBlKG9iaikpe1xyXG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGEgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgaW4gb2JqKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYob2JqW2ldICE9PSB1bmRlZmluZWQpIG5ld0RhdGFbaV0gPSBvYmpbaV1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0RhdGFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZW5jb2RlKHN0cil7XHJcbiAgICAgICAgdmFyIG91dCwgaSwgbGVuO1xyXG4gICAgICAgIHZhciBjMSwgYzIsIGMzO1xyXG4gICAgICAgIHN0ciA9ICcnLmNvbmNhdChzdHIpO1xyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgb3V0ID0gXCJcIjtcclxuICAgICAgICB3aGlsZShpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGMxID0gc3RyLmNoYXJDb2RlQXQoaSsrKSAmIDB4ZmY7XHJcbiAgICAgICAgICAgIGlmKGkgPT0gbGVuKSB7XHJcbiAgICAgICAgICAgICAgICBvdXQgKz0gZW5jb2RlQ2hhcnMuY2hhckF0KGMxID4+IDIpO1xyXG4gICAgICAgICAgICAgICAgb3V0ICs9IGVuY29kZUNoYXJzLmNoYXJBdCgoYzEgJiAweDMpIDw8IDQpO1xyXG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiPT1cIjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQoaSsrKTtcclxuICAgICAgICAgICAgaWYoaSA9PSBsZW4pIHtcclxuICAgICAgICAgICAgICAgIG91dCArPSBlbmNvZGVDaGFycy5jaGFyQXQoYzEgPj4gMik7XHJcbiAgICAgICAgICAgICAgICBvdXQgKz0gZW5jb2RlQ2hhcnMuY2hhckF0KCgoYzEgJiAweDMpPDwgNCkgfCAoKGMyICYgMHhGMCkgPj4gNCkpO1xyXG4gICAgICAgICAgICAgICAgb3V0ICs9IGVuY29kZUNoYXJzLmNoYXJBdCgoYzIgJiAweEYpIDw8IDIpO1xyXG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiPVwiO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYzMgPSBzdHIuY2hhckNvZGVBdChpKyspO1xyXG4gICAgICAgICAgICBvdXQgKz0gZW5jb2RlQ2hhcnMuY2hhckF0KGMxID4+IDIpO1xyXG4gICAgICAgICAgICBvdXQgKz0gZW5jb2RlQ2hhcnMuY2hhckF0KCgoYzEgJiAweDMpPDwgNCkgfCAoKGMyICYgMHhGMCkgPj4gNCkpO1xyXG4gICAgICAgICAgICBvdXQgKz0gZW5jb2RlQ2hhcnMuY2hhckF0KCgoYzIgJiAweEYpIDw8IDIpIHwgKChjMyAmIDB4QzApID4+NikpO1xyXG4gICAgICAgICAgICBvdXQgKz0gZW5jb2RlQ2hhcnMuY2hhckF0KGMzICYgMHgzRik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9LFxyXG4gICAgZGVjb2RlKHN0cil7XHJcbiAgICAgICAgdmFyIGMxLCBjMiwgYzMsIGM0O1xyXG4gICAgICAgIHZhciBpLCBsZW4sIG91dDtcclxuICAgICAgICBzdHIgPSAnJy5jb25jYXQoc3RyKTtcclxuICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgICAgIG91dCA9IFwiXCI7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgYzEgPSBkZWNvZGVDaGFyc1tzdHIuY2hhckNvZGVBdChpKyspICYgMHhmZl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgYzEgPT0gLTEpO1xyXG4gICAgICAgICAgICBpZiAoYzEgPT0gLTEpIFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGMyID0gZGVjb2RlQ2hhcnNbc3RyLmNoYXJDb2RlQXQoaSsrKSAmIDB4ZmZdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuICYmIGMyID09IC0xKTtcclxuICAgICAgICAgICAgaWYgKGMyID09IC0xKSBcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYzEgPDwgMikgfCAoKGMyICYgMHgzMCkgPj4gNCkpO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBjMyA9IHN0ci5jaGFyQ29kZUF0KGkrKykgJiAweGZmO1xyXG4gICAgICAgICAgICAgICAgaWYgKGMzID09IDYxKSBcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgICAgICAgICAgICAgYzMgPSBkZWNvZGVDaGFyc1tjM107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4gJiYgYzMgPT0gLTEpO1xyXG4gICAgICAgICAgICBpZiAoYzMgPT0gLTEpIFxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYzIgJiAwWEYpIDw8IDQpIHwgKChjMyAmIDB4M0MpID4+IDIpKTtcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgYzQgPSBzdHIuY2hhckNvZGVBdChpKyspICYgMHhmZjtcclxuICAgICAgICAgICAgICAgIGlmIChjNCA9PSA2MSkgXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcclxuICAgICAgICAgICAgICAgIGM0ID0gZGVjb2RlQ2hhcnNbYzRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuICYmIGM0ID09IC0xKTtcclxuICAgICAgICAgICAgaWYgKGM0ID09IC0xKSBcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMzICYgMHgwMykgPDwgNikgfCBjNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgVXRpbHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUE1QkE7QUE4QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBUkE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFRQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUdBO0FBYkE7QUFlQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUEzZEE7QUE0ZEEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/index.js\n");

/***/ })

};